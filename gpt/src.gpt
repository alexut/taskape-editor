readme.md:
# Taskape Task Editor
A vanilla drag-and-drop UI tree for managing tasks, based on David Figatner's drag-and-drop ui tree

## Rationale
Taskape Task Editor is designed to provide an easy-to-use, drag-and-drop interface for managing hierarchical tasks without the need for frameworks like Vue or React.

## Interaction Diagram

```mermaid
sequenceDiagram
    participant User
    participant Tree
    participant Input
    participant Clicked
    participant Leaf
    participant TaskEditor

    User->>Leaf: mousedown/touchstart (double-click)
    Leaf->>Clicked: touchstart(e)
    Leaf->>Clicked: touchend(e)
    Clicked->>Clicked: mousedblclick(e)
    Clicked->>TaskEditor: editTask(Leaf)
    TaskEditor->>TaskEditor: taskArea.innerText = leaf.data.name
    TaskEditor->>TaskEditor: Show editTaskBtn, Hide createTaskBtn

    User->>TaskEditor: Edit text in taskArea
    TaskEditor->>TaskEditor: onTaskAreaInput()
    TaskEditor->>TaskEditor: Update button visibility

    User->>TaskEditor: Click editTaskBtn
    TaskEditor->>Leaf: leaf.data.name = taskArea.innerText.trim()
    TaskEditor->>Tree: tree.update()
    Tree->>Tree: _createLeaf(data, level) (for each leaf)
    Tree->>Tree: Update DOM structure
    TaskEditor->>TaskEditor: resetTaskArea()
```

## UML Class Diagram

```mermaid
classDiagram
  class Tree {
    -_options: Object
    -_input: Input
    -taskEditor: TaskEditor
    +element: HTMLElement
    +_selection: HTMLElement
    +constructor(tree: Object, options: Object)
    -_createLeaf(data: Object, level: number): Leaf
    -_getChildren(leaf: HTMLElement, all: boolean): HTMLElement[]
    +expandAll()
    -_expandChildren(leaf: HTMLElement)
    +collapseAll()
    -_collapseChildren(leaf: HTMLElement)
    +toggleExpand(leaf: HTMLElement)
    +expand(leaf: HTMLElement) 
    +collapse(leaf: HTMLElement) 
    +update()
    +editData(data: Object)
    +getLeaf(leaf: HTMLElement, root: HTMLElement)
    +findInTree(leaf: HTMLElement, callback: Function)
    -_getFirstChild(element: HTMLElement, all: boolean): HTMLElement
    -_getLastChild(element: HTMLElement, all: boolean): HTMLElement
    -_getParent(element: HTMLElement): HTMLElement
  }

  class Leaf {
    -tree: Tree
    -data: Object
    -level: number
    -element: HTMLElement
    +constructor(tree: Tree, data: Object, level: number)
    +getChildren(all: boolean): HTMLElement[]
    +hideIcon()
    +showIcon()
    +expand()
    +collapse()
    +selectLeaf()
  }

  class Input {
    +_tree: Tree
    +_indicator: Indicator
    +_target: HTMLElement
    +_isDown: Object
    +_offset: Object
    +_holdTimeout: number
    +_moving: boolean
    +_old: Object
    +_closest: Object
    +constructor(tree: Tree)
    -_down(e: Event)
    -_hold()
    -_checkThreshold(e: Event): boolean
    -_pickup()
    -_findClosest(e: Event, entry: HTMLElement)
    -_move(e: Event)
    -_up(e)
    -_moveData()
    -_indicatorMarginLeft(value: number)
  }

  class Indicator {
    +_indicator: HTMLElement
    +constructor(tree: Tree)
    +get(): HTMLElement
    +set marginLeft(value: number)
  }

  class Clicked {
    +Clicked(element, callback, options)
    +destroy()
    +touchstart(e)
    +touchmove(e)
    +touchcancel()
    +touchend(e)
    +mouseclick(e)
    +mousedblclick(e)
  }

  class TaskEditor {
    +tree: Tree
    +currentTask: Leaf | null
    +taskArea: HTMLElement
    +createTaskBtn: HTMLElement
    +editTaskBtn: HTMLElement
    +placeholderText: string
    +constructor(tree: Tree)
    +setupPlaceholder()
    +createTask()
    +updateTask()
    +onTaskAreaInput()
    +resetTaskArea()
    +editTask(leaf: Leaf)
  }

  class Utils {
    +static el(element)
    +static distance(x1, y1, x2, y2)
    +static distancePointElement(px, py, element)
    +static boolean inside(x, y, element)
    +static PointLike toGlobal(e)
    +static object options(options, defaults)
    +static void style(element, style, value)
    +static number percentage(xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2)
    +static void removeChildren(element)
    +static HTMLElement html(options)
    +static number getChildIndex(parent, child)
    +static void attachStyles(styles)
  }

  Tree --> Leaf
  Tree --> TaskEditor
  Input --> Tree
  Input --> Indicator
  Clicked --> Input
  Tree --> Utils

```

## Super Simple Example
```js
const tasks = {
    task: [
        { 
            name: 'Do the laundry',
            task: [
                { name: 'Get the detergent', task: [] },
                { name: 'Sort the clothes', task: [] },
                { name: 'Put the clothes in the washing machine', task: [] },
                { name: 'Turn on the washing machine', task: [] }
            ] 
        },
        { 
            name: 'Do the dishes',
            task: [
                { name: 'Scrape the dishes', task: [] },
                { name: 'Rinse the dishes', task: [] },
                { name: 'Put the dishes in the dishwasher', task: [] },
                { name: 'Turn on the dishwasher', task: [] }
            ]
        }
    ]
};

const tree = new Tree(tasks, { parent: document.body, edit: true });
tree.expandAll();
```

## Features
- Drag-and-drop tasks
- Indentation for nested tasks
- Expand/collapse tasks
- Edit task names
- Add new tasks
- Delete tasks


## Tasks
Tasks are represented as a JavaScript object, where each task is an object with a `name` string and a `task` array of subtasks.


## License
Taskape Task Editor is released under the [MIT License](https://opensource.org/licenses/MIT).
```

## Credits
- [David Figatner] 

index.html:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Editor</title>
    <link rel="stylesheet" href="main.css">
    <script>
        window.suggestions = {
            tags: {
                assigned: ['Alex', 'Valentin', 'Sergiy', '?assigned'],
                estimate: ['5h', '30min', '2h', '1h', '6h', '?estimate'],
                due: ['tomorrow', 'EOD', 'one week', 'one month', '?due']
            },
            actions: {
                cmd: ['?cmd'],
                cursor: ['?mouseX', '?mouseY']
            },
            oracles: {
                example: ['oracle1', 'oracle2', '?oracle']
            }
        };

        window.tasks = {
            task: [
                { 
                    name: 'Do the laundry',
                    task: [
                        { name: 'Get the detergent', task: [] },
                        { name: 'Sort the clothes', task: [] },
                        { name: 'Put the clothes in the washing machine', task: [] },
                        { name: 'Turn on the washing machine', task: [] }
                    ] 
                },
                { 
                    name: 'Do the dishes',
                    task: [
                        { name: 'Scrape the dishes', task: [] },
                        { name: 'Rinse the dishes', task: [] },
                        { name: 'Put the dishes in the dishwasher', task: [] },
                        { name: 'Turn on the dishwasher', task: [] }
                    ]
                }
            ]
        };
    </script>
</head>
<body class="bg-gray-100">
    <div class="title text-3xl font-bold text-center py-4">Taskape Task Editor</div>
    <div id="tasktree" class="p-4"></div>
    <div id="taskeditor" class="bg-white shadow-md rounded-lg p-4 m-4">
        <div id="taskarea" class="border p-2 rounded" contenteditable data-placeholder="Add your task here">
            Add your task here
        </div>
        <div class="taskoptions mt-4">
            <button id="createTaskBtn" class="bg-blue-500 text-white py-2 px-4 rounded">Add</button>
            <button class="hidden bg-green-500 text-white py-2 px-4 rounded" id="editTaskBtn">Edit</button> 
        </div>
    </div>
    <script src="index.js"></script>
</body>
</html>


src/clicked.js:
'use strict';

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }

    return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();

function clicked(element, callback, options = {}) {
    return new Clicked(element, callback, options);
}

var Clicked = function () {
    function Clicked(element, callback, options) {
        var _this = this;

        _classCallCheck(this, Clicked);

        this.options = options;
        this.threshhold = this.options.threshhold || 10;
        this.events = {
            mouseclick: function mouseclick(e) {
                return _this.mouseclick(e);
            },
            mousedblclick: function mousedblclick(e) {
                return _this.mousedblclick(e);
            },
            touchstart: function touchstart(e) {
                return _this.touchstart(e);
            },
            touchmove: function touchmove(e) {
                return _this.touchmove(e);
            },
            touchcancel: function touchcancel(e) {
                return _this.touchcancel(e);
            },
            touchend: function touchend(e) {
                return _this.touchend(e);
            }
        };
        element.addEventListener('click', this.events.mouseclick);
        element.addEventListener('dblclick', this.events.mousedblclick);
        element.addEventListener('touchstart', this.events.touchstart, { passive: true });
        element.addEventListener('touchmove', this.events.touchmove, { passive: true });
        element.addEventListener('touchcancel', this.events.touchcancel);
        element.addEventListener('touchend', this.events.touchend);
        this.element = element;
        this.callback = callback;
        this.doubleClickCallback = this.options.doubleClickCallback;
    }

    _createClass(Clicked, [{
        key: 'destroy',
        value: function destroy() {
            this.element.removeEventListener('click', this.events.mouseclick);
            this.element.removeEventListener('dblclick', this.events.mousedblclick);
            this.element.removeEventListener('touchstart', this.events.touchstart);
            this.element.removeEventListener('touchmove', this.events.touchmove);
            this.element.removeEventListener('touchcancel', this.events.touchcancel);
            this.element.removeEventListener('touchend', this.events.touchend);
        }
    }, {
        key: 'touchstart',
        value: function touchstart(e) {
            if (e.touches.length === 1) {
                this.lastX = e.changedTouches[0].screenX;
                this.lastY = e.changedTouches[0].screenY;
                this.down = true;
            }
        }
    }, {
        key: 'pastThreshhold',
        value: function pastThreshhold(x, y) {
            return Math.abs(this.lastX - x) > this.threshhold || Math.abs(this.lastY - y) > this.threshhold;
        }
    }, {
        key: 'touchmove',
        value: function touchmove(e) {
            if (!this.down || e.touches.length !== 1) {
                this.touchcancel();
                return;
            }
            var x = e.changedTouches[0].screenX;
            var y = e.changedTouches[0].screenY;
            if (this.pastThreshhold(x, y)) {
                this.touchcancel();
            }
        }
    }, {
        key: 'touchcancel',
        value: function touchcancel() {
            this.down = false;
        }
    }, {
        key: 'touchend',
        value: function touchend(e) {
            if (this.down) {
                e.preventDefault();
                if (this.callback) {
                    this.callback(e, this.options.args);
                }
            }
        }
    }, {
        key: 'mouseclick',
        value: function mouseclick(e) {
            if (this.callback) {
                this.callback(e, this.options.args);
            }
        }
    }, {
        key: 'mousedblclick',
        value: function mousedblclick(e) {
            if (this.doubleClickCallback) {
                this.doubleClickCallback(e, this.options.args);
            }
        }
    }]);

    return Clicked;
}();

export default clicked;


src/defaults.js:
export const defaults = {
    move: true,
    select: true,
    indentation: 20,
    threshold: 10,
    holdTime: 1000,
    expandOnClick: false,
    dragOpacity: 0.75,
    prefixClassName: 'mb-task',
    cursorName: 'grab -webkit-grab pointer',
    cursorExpand: 'pointer',
    edit: true, 
    symbols: {
        oracles: '#',
        tags: '@',
        actions: '>'
    }
};


src/editor.js:
'use strict';

import * as utils from './utils';

export class TaskEditor {
    constructor(tree) {
        this.tree = tree;
        this.currentTask = null;
        this.taskArea = document.getElementById('taskarea');
        this.createTaskBtn = document.getElementById('createTaskBtn');
        this.editTaskBtn = document.getElementById('editTaskBtn');
        this.placeholderText = this.taskArea.getAttribute('data-placeholder');

        this.createTaskBtn.addEventListener('click', () => this.createTask());
        this.editTaskBtn.addEventListener('click', () => this.updateTask());
        this.taskArea.addEventListener('input', () => this.onTaskAreaInput());

        this.setupPlaceholder();
    }

    setupPlaceholder() {
        const setPlaceholder = () => {
            if (this.taskArea.innerText.trim() === '') {
                this.taskArea.innerText = this.placeholderText;
                this.taskArea.classList.add('placeholder');
            }
        };

        const removePlaceholder = () => {
            if (this.taskArea.innerText === this.placeholderText) {
                this.taskArea.innerText = '';
                this.taskArea.classList.remove('placeholder');
            }
        };

        this.taskArea.addEventListener('focus', removePlaceholder);
        this.taskArea.addEventListener('blur', setPlaceholder);

        setPlaceholder(); // Initial call to set the placeholder
    }

    createTask() {
        const taskName = this.taskArea.innerText.trim();
        if (taskName && taskName !== this.placeholderText) {
            const selectedLeaf = document.querySelector(`.${this.tree.prefixClassName}-leaf-select`);
            const newTask = { name: taskName, task: [] };

            if (selectedLeaf) {
                const selectedLeafInstance = selectedLeaf.__leafInstance;
                if (selectedLeafInstance && selectedLeafInstance.data) {
                    const parentTask = selectedLeafInstance.data.parent;
                    if (parentTask) {
                        const siblingIndex = parentTask.task.indexOf(selectedLeafInstance.data);
                        parentTask.task.splice(siblingIndex + 1, 0, newTask);
                    } else {
                        console.error('Parent task not found for the selected leaf');
                    }
                } else {
                    console.error('Selected leaf instance or its data is not defined');
                }
            } else {
                if (this.tree.element.data && this.tree.element.data.task) {
                    this.tree.element.data.task.push(newTask);
                } else {
                    console.error('Tree data or tree data task array is not defined');
                }
            }

            this.tree.update();
            this.resetTaskArea();
        }
    }

    updateTask() {
        if (this.currentTask) {
            this.currentTask.data.name = this.taskArea.innerText.trim();
            this.tree.update();
            this.resetTaskArea();
        }
    }

    onTaskAreaInput() {
        const taskName = this.taskArea.innerText.trim();
        if (this.currentTask && taskName && taskName !== this.placeholderText) {
            this.editTaskBtn.classList.remove('hidden');
            this.createTaskBtn.classList.add('hidden');
        } else {
            this.editTaskBtn.classList.add('hidden');
            this.createTaskBtn.classList.remove('hidden');
        }
    }

    resetTaskArea() {
        this.taskArea.innerText = '';
        this.taskArea.blur(); // Triggers the placeholder to be set
        this.editTaskBtn.classList.add('hidden');
        this.createTaskBtn.classList.remove('hidden');
        this.currentTask = null;
    }

    editTask(leaf) {
        this.currentTask = leaf;
        this.taskArea.innerText = leaf.data.name;
        this.editTaskBtn.classList.remove('hidden');
        this.createTaskBtn.classList.add('hidden');
        this.taskArea.focus();
    }
}


src/indicator.js:
import * as utils from './utils';

export class Indicator {
    constructor(tree) {
        this._indicator = utils.html();
        this._indicator.style.marginLeft = tree.indentation + 'px';
        const content = utils.html({ parent: this._indicator });
        content.style.display = 'flex';
        this._indicator.indentation = utils.html({ parent: content });
        this._indicator.icon = utils.html({ parent: content, className: `${tree.prefixClassName}-expand` });
        this._indicator.icon.style.height = 0;
        this._indicator.line = utils.html({ parent: content, className: `${tree.prefixClassName}-indicator` });
    }

    get() {
        return this._indicator;
    }

    set marginLeft(value) {
        this._indicator.style.marginLeft = value + 'px';
    }
}


src/init.js:
import { Tree } from './tree';
import { TaskEditor } from './editor';

function initializeTree() {
    const tasks = window.tasks;
    const tree = new Tree(tasks, { parent: document.getElementById('tasktree') });
    tree.expandAll();
    window.taskEditor = new TaskEditor(tree); // Ensure taskEditor is assigned to the tree instance
    tree.taskEditor = window.taskEditor;
}

window.onload = function () {
    initializeTree();
};


src/input.js:
'use strict';

import * as utils from './utils';
import { Indicator } from './indicator';

export class Input {
    constructor(tree) {
        this._tree = tree;
        this._indicator = new Indicator(tree);
        document.body.addEventListener('mousemove', e => this._move(e));
        document.body.addEventListener('touchmove', e => this._move(e));
        document.body.addEventListener('mouseup', e => this._up(e));
        document.body.addEventListener('touchend', e => this._up(e));
        document.body.addEventListener('mouseleave', e => this._up(e));
    }

    _down(e) {
        if (e.target.classList.contains(`${this._tree.prefixClassName}-leaf-handler`)) {
            // Start drag and drop
            this._target = e.currentTarget.parentNode.parentNode;
            let alreadySelected = false;
            if (this._tree._selection === this._target) {
                alreadySelected = true;
            } else {
                if (this._tree._selection) {
                    this._tree._selection.querySelector(`.${this._tree.prefixClassName}-name`).classList.remove(`${this._tree.prefixClassName}-select`);
                }
                this._tree._selection = this._target;
                this._tree._selection.querySelector(`.${this._tree.prefixClassName}-name`).classList.add(`${this._tree.prefixClassName}-select`);
            }
            this._isDown = { x: e.pageX, y: e.pageY, alreadySelected };
            const pos = utils.toGlobal(this._target);
            this._offset = { x: e.pageX - pos.x, y: e.pageY - pos.y };
            if (this._tree.holdTime) {
                this._holdTimeout = window.setTimeout(() => this._hold(), this._tree.holdTime);
            }
            e.preventDefault();
            e.stopPropagation();
        } else {
            // Handle selection
            this._target = e.currentTarget.parentNode.parentNode;
            if (this._tree._selection !== this._target) {
                if (this._tree._selection) {
                    this._tree._selection.querySelector(`.${this._tree.prefixClassName}-name`).classList.remove(`${this._tree.prefixClassName}-select`);
                }
                this._tree._selection = this._target;
                this._tree._selection.querySelector(`.${this._tree.prefixClassName}-name`).classList.add(`${this._tree.prefixClassName}-select`);
                this._tree.emit('selection-change', this._target, this._tree);
            }
        }
    }

    _hold() {
        this._holdTimeout = null;
        this._tree.edit(this._target);
    }

    _checkThreshold(e) {
        if (!this._isDown) {
            return false;
        }
        if (!this._tree.move) {
            return false;
        } else if (this._moving) {
            return true;
        } else {
            if (utils.distance(this._isDown.x, this._isDown.y, e.pageX, e.pageY)) {
                this._moving = true;
                this._pickup();
                return true;
            } else {
                return false;
            }
        }
    }

    _pickup() {
        if (this._holdTimeout) {
            window.clearTimeout(this._holdTimeout);
            this._holdTimeout = null;
        }
        this._tree.emit('move-pending', this._target, this._tree);
        const parent = this._target.parentNode;
        parent.insertBefore(this._indicator.get(), this._target);
        const pos = utils.toGlobal(this._target);
        document.body.appendChild(this._target);
        this._old = {
            opacity: this._target.style.opacity || 'unset',
            position: this._target.style.position || 'unset',
            boxShadow: this._target.querySelector(`.${this._tree.prefixClassName}-name`).style.boxShadow || 'unset'
        };
        this._target.style.position = 'absolute';
        this._target.querySelector(`.${this._tree.prefixClassName}-name`).style.boxShadow = '3px 3px 5px rgba(0,0,0,0.25)';
        this._target.style.left = pos.x + 'px';
        this._target.style.top = pos.y + 'px';
        this._target.style.opacity = this._tree.dragOpacity;
        if (this._tree._getChildren(parent, true).length === 0) {
            parent.hideIcon();
        }
    }

    _findClosest(e, entry) {
        const pos = utils.toGlobal(entry.querySelector(`.${this._tree.prefixClassName}-name`));
        if (pos.y + entry.querySelector(`.${this._tree.prefixClassName}-name`).offsetHeight / 2 <= e.pageY) {
            if (!this._closest.foundAbove) {
                if (utils.inside(e.pageX, e.pageY, entry.querySelector(`.${this._tree.prefixClassName}-name`))) {
                    this._closest.foundAbove = true;
                    this._closest.above = entry;
                } else {
                    const distance = utils.distancePointElement(e.pageX, e.pageY, entry.querySelector(`.${this._tree.prefixClassName}-name`));
                    if (distance < this._closest.distanceAbove) {
                        this._closest.distanceAbove = distance;
                        this._closest.above = entry;
                    }
                }
            }
        } else if (!this._closest.foundBelow) {
            if (utils.inside(e.pageX, e.pageY, entry.querySelector(`.${this._tree.prefixClassName}-name`))) {
                this._closest.foundBelow = true;
                this._closest.below = entry;
            } else {
                const distance = utils.distancePointElement(e.pageX, e.pageY, entry.querySelector(`.${this._tree.prefixClassName}-name`));
                if (distance < this._closest.distanceBelow) {
                    this._closest.distanceBelow = distance;
                    this._closest.below = entry;
                }
            }
        }
        for (let child of this._tree._getChildren(entry)) {
            this._findClosest(e, child);
        }
    }

    _move(e) {
        if (this._target && this._checkThreshold(e)) {
            const element = this._tree.element;
            const indicator = this._indicator.get();
            const indentation = this._tree.indentation;
            indicator.remove();
            this._target.style.left = e.pageX - this._offset.x + 'px';
            this._target.style.top = e.pageY - this._offset.y + 'px';
            const x = utils.toGlobal(this._target.querySelector(`.${this._tree.prefixClassName}-name`)).x;
            this._closest = { distanceAbove: Infinity, distanceBelow: Infinity };
            for (let child of this._tree._getChildren()) {
                this._findClosest(e, child);
            }
            if (!this._closest.above && !this._closest.below) {
                element.appendChild(indicator);
            } else if (!this._closest.above)  {
                // null [] leaf
                element.insertBefore(indicator, this._tree._getFirstChild(element));
            } else if (!this._closest.below) {
                // leaf [] null
                let pos = utils.toGlobal(this._closest.above.querySelector(`.${this._tree.prefixClassName}-name`));
                if (x > pos.x + indentation) {
                    this._closest.above.insertBefore(indicator, this._tree._getFirstChild(this._closest.above, true));
                } else if (x > pos.x - indentation) {
                    this._closest.above.parentNode.appendChild(indicator);
                } else {
                    let parent = this._closest.above;
                    while (parent !== element && x < pos.x) {
                        parent = this._tree._getParent(parent);
                        if (parent !== element) {
                            pos = utils.toGlobal(parent.querySelector(`.${this._tree.prefixClassName}-name`));
                        }
                    }
                    parent.appendChild(indicator);
                }
            } else if (this._closest.below.parentNode === this._closest.above) {
                // parent [] child
                this._closest.above.insertBefore(indicator, this._closest.below);
            } else if (this._closest.below.parentNode === this._closest.above.parentNode) {
                // sibling [] sibling
                const pos = utils.toGlobal(this._closest.above.querySelector(`.${this._tree.prefixClassName}-name`));
                if (x > pos.x + indentation) {
                    this._closest.above.insertBefore(indicator, this._tree._getLastChild(this._closest.above, true));
                } else {
                    this._closest.above.parentNode.insertBefore(indicator, this._closest.below);
                }
            } else {
                // child [] parent^
                let pos = utils.toGlobal(this._closest.above.querySelector(`.${this._tree.prefixClassName}-name`));
                if (x > pos.x + indentation) {
                    this._closest.above.insertBefore(indicator, this._tree._getLastChild(this._closest.above, true));
                } else if (x > pos.x - indentation) {
                    this._closest.above.parentNode.appendChild(indicator);
                } else if (x < utils.toGlobal(this._closest.below.querySelector(`.${this._tree.prefixClassName}-name`)).x) {
                    this._closest.below.parentNode.insertBefore(indicator, this._closest.below);
                } else {
                    let parent = this._closest.above;
                    while (parent.parentNode !== this._closest.below.parentNode && x < pos.x) {
                        parent = this._tree._getParent(parent);
                        pos = utils.toGlobal(parent.querySelector(`.${this._tree.prefixClassName}-name`));
                    }
                    parent.appendChild(indicator);
                }
            }
        }
    }

    _up(e) {
        if (this._target) {
            if (!this._moving) {
                if (this._tree.expandOnClick && (!this._tree.select || this._isDown.alreadySelected)) {
                    this._tree.toggleExpand(this._target);
                }
                this._tree.emit('clicked', this._target, e, this._tree);
            } else {
                const indicator = this._indicator.get();
                indicator.parentNode.insertBefore(this._target, indicator);
                this._tree.expand(indicator.parentNode);
                const leafInstance = indicator.parentNode.__leafInstance;
                if (leafInstance) {
                    leafInstance.showIcon();
                }
                this._target.style.position = this._old.position === 'unset' ? '' : this._old.position;
                this._target.querySelector(`.${this._tree.prefixClassName}-name`).style.boxShadow = this._old.boxShadow === 'unset' ? '' : this._old.boxShadow;
                this._target.style.opacity = this._old.opacity === 'unset' ? '' : this._old.opacity;
                indicator.remove();
                this._moveData();
                this._tree.emit('move', this._target, this._tree);
                this._tree.emit('update', this._target, this._tree);
            }
            if (this._holdTimeout) {
                window.clearTimeout(this._holdTimeout);
                this._holdTimeout = null;
            }
            this._target = this._moving = null;
            this._isDown = null;  // Reset _isDown
        }
    }

    _moveData() {
        this._target.data.parent.task.splice(this._target.data.parent.task.indexOf(this._target.data), 1);
        this._target.parentNode.data.task.splice(utils.getChildIndex(this._target.parentNode, this._target), 0, this._target.data);
        this._target.data.parent = this._target.parentNode.data;
    }

    _indicatorMarginLeft(value) {
        this._indicator.marginLeft = value;
    }
}


src/leaf.js:
'use strict';

import clicked from './clicked';
import * as utils from './utils';

export class Leaf {
    constructor(data, level, tree) {
        this.data = data;
        this.tree = tree;
        this.level = level;
        this.element = utils.html({ className: `${tree.prefixClassName}-leaf` });
        this.element.isLeaf = true;
        this.element.__leafInstance = this;
        this.element.data = data;
        this.element.content = utils.html({ parent: this.element, className: `${tree.prefixClassName}-content` });
        this.element.style.marginLeft = `${tree.indentation}px`;
        const iconClass = `${tree.prefixClassName}-expand${data.expanded ? ' expanded' : ''}`;
        this.element.icon = utils.html({
            parent: this.element.content,
            className: iconClass.trim()
        });
        this.element.name = utils.html({ parent: this.element.content, html: data.name, className: `${tree.prefixClassName}-name` });

        // Add a handler for dragging
        this.element.handler = utils.html({ parent: this.element.content, className: `${tree.prefixClassName}-leaf-handler` });
        this.element.handler.addEventListener('mousedown', e => tree._input._down(e));
        this.element.handler.addEventListener('touchstart', e => tree._input._down(e));

        // Handle selection on the leaf
        this.element.name.addEventListener('mousedown', e => {
            tree._input._down(e);
            this.selectLeaf();
        });
        this.element.name.addEventListener('touchstart', e => {
            tree._input._down(e);
            this.selectLeaf();
        });

        // Use clicked to handle single-click for selection and double-click for updating task area
        clicked(this.element.name, () => {}, {
            doubleClickCallback: () => {
                if (tree.taskEditor && typeof tree.taskEditor.editTask === 'function') {
                    tree.taskEditor.editTask(this);
                } else {
                    console.error('editTask method not found in taskEditor');
                }
            }
        });

        // Ensure the task property is always an array
        data.task = data.task || [];
        for (let child of data.task) {
            const add = new Leaf(child, level + 1, tree);
            add.data.parent = data;
            this.element.appendChild(add.element);
            if (!data.expanded) {
                add.element.style.display = 'none';
            }
        }
        if (this.getChildren(true).length === 0) {
            this.hideIcon();
        }
        this.element.icon.addEventListener('click', () => tree.toggleExpand(this.element));
        tree.emit('render', this.element, tree);
    }

    getChildren(all) {
        const children = [];
        for (let child of this.element.children) {
            if (child.isLeaf && (all || child.style.display !== 'none')) {
                children.push(child);
            }
        }
        return children;
    }

    hideIcon() {
        if (this.element.isLeaf) {
            this.element.icon.classList.add('hidden');
        }
    }

    showIcon() {
        if (this.element.isLeaf) { 
            this.element.icon.classList.remove('hidden');
        }
    }

    selectLeaf() {
        const selectedLeaf = document.querySelector(`.${this.tree.prefixClassName}-leaf-select`);
        if (selectedLeaf) {
            selectedLeaf.classList.remove(`${this.tree.prefixClassName}-leaf-select`);
        }
        this.element.classList.add(`${this.tree.prefixClassName}-leaf-select`);
    }
}


src/tree.js:
'use strict';

import Events from 'eventemitter3';
import { Input } from './input';
import { defaults } from './defaults';
import { Leaf } from './leaf';
import { TaskEditor } from './editor';
import * as utils from './utils';

export class Tree extends Events {
    constructor(tree, options) {
        super();
        this._options = utils.options(options, defaults);
        this._input = new Input(this);
        this.taskEditor = new TaskEditor(this);
        if (typeof this._options.element === 'undefined') {
            this.element = document.createElement('div');
        } else {
            this.element = utils.el(this._options.element);
        }
        if (this._options.parent) {
            utils.el(this._options.parent).appendChild(this.element);
        }
        this.element.classList.add(this.prefixClassName);
        this.element.data = tree;
        this.update();
    }

    get selection() {
        return this._selection.data;
    }
    set selection(data) {}

    get prefixClassName() {
        return this._options.prefixClassName;
    }
    set prefixClassName(value) {
        if (value !== this._options.prefixClassName) {
            this._options.prefixClassName = value;
            this.update();
        }
    }

    get indentation() {
        return this._options.indentation;
    }
    set indentation(value) {
        if (value !== this._options.indentation) {
            this._options.indentation = value;
            this._input._indicatorMarginLeft = value + 'px';
            this.update();
        }
    }

    get holdTime() {
        return this._options.holdTime;
    }
    set holdTime(value) {
        if (value !== this._options.holdTime) {
            this._options.holdTime = value;
        }
    }

    get move() {
        return this._options.move;
    }
    set move(value) {
        this._options.move = value;
    }

    get expandOnClick() {
        return this._options.expandOnClick;
    }
    set expandOnClick(value) {
        this._options.expandOnClick = value;
    }

    get select() {
        return this._options.select;
    }
    set select(value) {
        this._options.select = value;
    }

    get dragOpacity() {
        return this._options.dragOpacity;
    }
    set dragOpacity(value) {
        this._options.dragOpacity = value;
    }

    expandAll() {
        this._expandChildren(this.element);
    }

    _expandChildren(leaf) {
        for (let child of this._getChildren(leaf, true)) {
            this.expand(child);
            this._expandChildren(child);
        }
    }

    collapseAll() {
        this._collapseChildren(this.element);
    }

    _collapseChildren(leaf) {
        for (let child of this._getChildren(leaf, true)) {
            this.collapse(child);
            this._collapseChildren(child);
        }
    }

    toggleExpand(leaf) {
        if (!leaf.icon.classList.contains('hidden')) {
            if (leaf.data.expanded) {
                this.collapse(leaf);
            } else {
                this.expand(leaf);
            }
        }
    }

    expand(leaf) {
        if (leaf.isLeaf) {
            const children = this._getChildren(leaf, true);
            if (children.length) {
                for (let child of children) {
                    child.style.display = 'block';
                }
                leaf.data.expanded = true;
                leaf.icon.classList.add('expanded');
                this.emit('expand', leaf, this);
                this.emit('update', leaf, this);
            }
        }
    }

    collapse(leaf) {
        if (leaf.isLeaf) {
            const children = this._getChildren(leaf, true);
            if (children.length) {
                for (let child of children) {
                    child.style.display = 'none';
                }
                leaf.data.expanded = false;
                leaf.icon.classList.remove('expanded');
                this.emit('collapse', leaf, this);
                this.emit('update', leaf, this);
            }
        }
    }

    update() {
        const scroll = this.element.scrollTop;
        utils.removeChildren(this.element);
        for (let leaf of this.element.data.task) {
            const add = new Leaf(leaf, 0, this);
            add.data.parent = this.element.data;
            add.element.__leafInstance = add;
            this.element.appendChild(add.element);
        }
        this.element.scrollTop = scroll + 'px';
    }

    editData(data) {
        const children = this._getChildren(null, true);
        for (let child of children) {
            if (child.data === data) {
                child.querySelector(`.${this.prefixClassName}-name`).setAttribute('contenteditable', true);
                child.querySelector(`.${this.prefixClassName}-name`).focus();
            }
        }
    }

    getLeaf(leaf, root = this.element) {
        this.findInTree(root, data => data === leaf);
    }

    findInTree(leaf, callback) {
        for (const child of leaf.children) {
            if (callback(child)) {
                return child;
            }
            const find = this.findInTree(child, callback);
            if (find) {
                return find;
            }
        }
    }

    _getFirstChild(element, all) {
        const children = this._getChildren(element, all);
        if (children.length) {
            return children[0];
        }
    }

    _getLastChild(element, all) {
        const children = this._getChildren(element, all);
        if (children.length) {
            return children[children.length - 1];
        }
    }

    _getParent(element) {
        element = element.parentNode;
        while (element.style.display === 'none') {
            element = element.parentNode;
        }
        return element;
    }

    _getChildren(leaf, all) {
        leaf = leaf || this.element;
        const children = [];
        for (let child of leaf.children) {
            if (child.isLeaf && (all || child.style.display !== 'none')) {
                children.push(child);
            }
        }
        return children;
    }
}


src/utils.js:
/**
 * converts a string to an HTMLElement if necessary
 * @param {(HTMLElement|string)} element
 */
export function el(element) {
    if (typeof element === 'string') {
        return document.querySelector(element)
    }
    return element

}

/**
 * measure distance between two points
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 */
export function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2))
}

/**
 * find shortest distance from point to HTMLElement's bounding box
 * from: https://gamedev.stackexchange.com/questions/44483/how-do-i-calculate-distance-between-a-point-and-an-axis-aligned-rectangle
 * @param {number} x
 * @param {number} y
 * @param {HTMLElement} element
 */
export function distancePointElement(px, py, element) {
    const pos = toGlobal(element)
    const width = element.offsetWidth
    const height = element.offsetHeight
    const x = pos.x + width / 2
    const y = pos.y + height / 2
    const dx = Math.max(Math.abs(px - x) - width / 2, 0)
    const dy = Math.max(Math.abs(py - y) - height / 2, 0)
    return dx * dx + dy * dy
}

/**
 * determine whether the mouse is inside an element
 * @param {HTMLElement} dragging
 * @param {HTMLElement} element
 */
export function inside(x, y, element) {
    const pos = toGlobal(element)
    const x1 = pos.x
    const y1 = pos.y
    const w1 = element.offsetWidth
    const h1 = element.offsetHeight
    return x >= x1 && x <= x1 + w1 && y >= y1 && y <= y1 + h1
}

/**
 * determines global location of a div
 * from https://stackoverflow.com/a/26230989/1955997
 * @param {HTMLElement} e
 * @returns {PointLike}
 */
export function toGlobal(e) {
    const box = e.getBoundingClientRect()

    const body = document.body
    const docEl = document.documentElement

    const scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop
    const scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft

    const clientTop = docEl.clientTop || body.clientTop || 0
    const clientLeft = docEl.clientLeft || body.clientLeft || 0

    const top = box.top + scrollTop - clientTop
    const left = box.left + scrollLeft - clientLeft

    return { y: Math.round(top), x: Math.round(left) }
}

/**
 * @typedef {object} PointLike
 * @property {number} x
 * @property {number} y
 */

/**
 * combines options and default options
 * @param {object} options
 * @param {object} defaults
 * @returns {object} options+defaults
 */
export function options(options, defaults) {
    options = options || {}
    for (let option in defaults) {
        options[option] = typeof options[option] !== 'undefined' ? options[option] : defaults[option]
    }
    return options
}

/**
 * set a style on an element
 * @param {HTMLElement} element
 * @param {string} style
 * @param {(string|string[])} value - single value or list of possible values (test each one in order to see if it works)
 */
export function style(element, style, value) {
    if (Array.isArray(value)) {
        for (let entry of value) {
            element.style[style] = entry
            if (element.style[style] === entry) {
                break
            }
        }
    } else {
        element.style[style] = value
    }
}

/**
 * calculate percentage of overlap between two boxes
 * from https://stackoverflow.com/a/21220004/1955997
 * @param {number} xa1
 * @param {number} ya1
 * @param {number} xa2
 * @param {number} xa2
 * @param {number} xb1
 * @param {number} yb1
 * @param {number} xb2
 * @param {number} yb2
 */
export function percentage(xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2) {
    const sa = (xa2 - xa1) * (ya2 - ya1)
    const sb = (xb2 - xb1) * (yb2 - yb1)
    const si = Math.max(0, Math.min(xa2, xb2) - Math.max(xa1, xb1)) * Math.max(0, Math.min(ya2, yb2) - Math.max(ya1, yb1))
    const union = sa + sb - si
    if (union !== 0) {
        return si / union
    } else {
        return 0
    }
}

export function removeChildren(element) {
    while (element.firstChild) {
        element.firstChild.remove()
    }
}

'use strict';

export function html(options) {
    options = options || {};
    const object = document.createElement(options.type || 'div');
    if (options.parent) {
        options.parent.appendChild(object);
    }
    if (options.className) {
        options.className.split(' ').forEach(cls => object.classList.add(cls));
    }
    if (options.html) {
        object.innerHTML = options.html;
    }
    if (options.id) {
        object.id = options.id;
    }
    if (options.attributes) {
        for (const key in options.attributes) {
            object.setAttribute(key, options.attributes[key]);
        }
    }
    return object;
}


export function getChildIndex(parent, child) {
    let index = 0
    for (let entry of parent.children) {
        if (entry === child) {
            return index
        }
        index++
    }
    return -1
}

export function attachStyles(styles) {
    const s = document.createElement('style')
    s.innerHTML = styles
    document.head.appendChild(s)
}

