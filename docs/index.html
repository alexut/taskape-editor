<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Home - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#distance">distance</a></li><li><a href="global.html#distancePointElement">distancePointElement</a></li><li><a href="global.html#el">el</a></li><li><a href="global.html#inside">inside</a></li><li><a href="global.html#options">options</a></li><li><a href="global.html#percentage">percentage</a></li><li><a href="global.html#style">style</a></li><li><a href="global.html#toGlobal">toGlobal</a></li></ul>
    
</nav>

<div id="main">
    

    



    


    <section class="package">
        <h3> </h3>		
    </section>









    



    <section class="readme usertext">
        <article><h1>BUG</h1>
<p>This section outlines the classes and methods involved in the autocomplete feature, emphasizing potential issues with the filter functionality. It includes a Mermaid.js diagram to visualize the interactions.</p>
<h2>Classes and Methods</h2>
<h3><code>AutocompleteManager</code></h3>
<p>The <code>AutocompleteManager</code> class handles the logic for the autocomplete feature, including detecting triggers, filtering elements, and inserting selected values into the task area.</p>
<h4>Methods</h4>
<ul>
<li>
<p><strong>constructor(popupElement)</strong></p>
<ul>
<li>Initializes the <code>AutocompleteManager</code> with a <code>Popup</code> instance.</li>
<li>Adds event listeners to the <code>taskarea</code> and document for input and keydown events, respectively.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>handleTaskAreaInput(event)</strong></p>
<ul>
<li>Handles input events in the <code>taskarea</code>.</li>
<li>Detects trigger characters (<code>@</code>, <code>&gt;</code>, <code>#</code>) and initiates the autocomplete process.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>detectTrigger(char)</strong></p>
<ul>
<li>Sets the trigger character and prepares the popup for showing relevant elements.</li>
<li>Clears and focuses the input field in the popup.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>showElements(category)</strong></p>
<ul>
<li>Retrieves and displays elements based on the trigger character category (<code>tags</code>, <code>actions</code>, <code>oracles</code>).</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>filterElements(text)</strong></p>
<ul>
<li>Filters elements based on the input text.</li>
<li>This method may not filter correctly and can block after writing the first letter due to issues with string conversion or filtering logic.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>renderElements()</strong></p>
<ul>
<li>Renders the filtered elements in the popup.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>handleKeyDown(event)</strong></p>
<ul>
<li>Handles keydown events for navigating and selecting elements within the popup.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>handlePopupInput(event)</strong></p>
<ul>
<li>Handles input events in the popup's input field.</li>
<li>Filters elements based on the input text.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>handlePopupClick(event)</strong></p>
<ul>
<li>Handles click events in the popup.</li>
<li>Inserts the selected element or value.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>insertSelectedElement()</strong></p>
<ul>
<li>Inserts the selected element into the <code>taskarea</code>.</li>
<li>Shows values for the selected element if applicable.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>showValues(values)</strong></p>
<ul>
<li>Displays possible values for the selected element in the popup.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>insertSelectedValue()</strong></p>
<ul>
<li>Inserts the selected value into the <code>taskarea</code> at the correct position.</li>
<li>Resets the state and focuses back to the <code>taskarea</code>.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>resetState()</strong></p>
<ul>
<li>Resets the state of the <code>AutocompleteManager</code> and hides the popup.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
</ul>
<h3><code>Popup</code></h3>
<p>The <code>Popup</code> class manages the display and interactions of the autocomplete popup.</p>
<h4>Methods</h4>
<ul>
<li>
<p><strong>constructor()</strong></p>
<ul>
<li>Initializes the <code>Popup</code> and creates the input field.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>showElements(elements, selectedIndex)</strong></p>
<ul>
<li>Displays the given elements in the popup with the selected index highlighted.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>hide()</strong></p>
<ul>
<li>Hides the popup.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>isVisible()</strong></p>
<ul>
<li>Checks if the popup is visible.</li>
<li>Returns: <code>boolean</code></li>
</ul>
</li>
<li>
<p><strong>handleInput(event)</strong></p>
<ul>
<li>Dispatches an input event with the current value of the popup's input field.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>placePopup(taskArea)</strong></p>
<ul>
<li>Positions the popup relative to the <code>taskarea</code>.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>createInputField()</strong></p>
<ul>
<li>Creates and initializes the input field for the popup.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>setInputValue(value)</strong></p>
<ul>
<li>Sets the value of the popup's input field.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>getInputValue()</strong></p>
<ul>
<li>Gets the value of the popup's input field.</li>
<li>Returns: <code>string</code></li>
</ul>
</li>
<li>
<p><strong>clearInputField()</strong></p>
<ul>
<li>Clears the value of the popup's input field.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
<li>
<p><strong>clearElements()</strong></p>
<ul>
<li>Clears all elements from the popup.</li>
<li>Returns: <code>void</code></li>
</ul>
</li>
</ul>
<h2>Potential Issues</h2>
<h3>Filter Method</h3>
<ul>
<li><strong>Issue</strong>: The <code>filterElements</code> method does not filter correctly and may block after writing the first letter.</li>
<li><strong>Cause</strong>: Potential issues with string conversion or filtering logic.</li>
<li><strong>Solution</strong>: Ensure text is correctly converted to a string and the filtering logic accurately matches the elements.</li>
</ul>
<h2>Mermaid.js Diagram</h2>
<pre class="prettyprint source lang-mermaid"><code>graph TD
    taskAreaInput[taskarea input event] --> handleTaskAreaInput{handleTaskAreaInput}
    handleTaskAreaInput -->|Trigger Detected| detectTrigger[detectTrigger]
    handleTaskAreaInput -->|No Trigger| Continue[Continue Typing]
    detectTrigger --> showElements[showElements]
    showElements --> renderElements[renderElements]
    renderElements --> showPopup[showPopup]
    showPopup --> popupInput[Popup input event]
    popupInput --> handlePopupInput{handlePopupInput}
    handlePopupInput --> filterElements[filterElements]
    filterElements --> renderFilteredElements[renderFilteredElements]

    subgraph Popup Class
        showPopup
        popupInput
    end

    subgraph AutocompleteManager Class
        handleTaskAreaInput
        detectTrigger
        showElements
        renderElements
        handlePopupInput
        filterElements
        renderFilteredElements
    end
</code></pre>
<h1>NEW FEATURE DEVELOPMENT:</h1>
<h2>Autocompolete manager popup</h2>
<pre class="prettyprint source lang-mermaid"><code>sequenceDiagram
    participant User
    participant TaskEditor
    participant AutocompleteManager
    participant Popup

    User->>TaskEditor: Type &quot;@&quot; or click #addTags
    TaskEditor->>AutocompleteManager: Detect &quot;@&quot; or button click
    AutocompleteManager->>AutocompleteManager: Fetch tags suggestions from window.suggestions
    AutocompleteManager->>Popup: Show tags suggestions

    User->>TaskEditor: Type &quot;>&quot; or click #addActions
    TaskEditor->>AutocompleteManager: Detect &quot;>&quot; or button click
    AutocompleteManager->>AutocompleteManager: Fetch actions suggestions from window.suggestions
    AutocompleteManager->>Popup: Show actions suggestions

    User->>TaskEditor: Type &quot;#&quot; or click #addOracles
    TaskEditor->>AutocompleteManager: Detect &quot;#&quot; or button click
    AutocompleteManager->>AutocompleteManager: Fetch oracles suggestions from window.suggestions
    AutocompleteManager->>Popup: Show oracles suggestions

    User->>Popup: Navigate and select suggestion
    Popup->>AutocompleteManager: Return selected suggestion
    AutocompleteManager->>AutocompleteManager: Fetch values for selected suggestion
    AutocompleteManager->>Popup: Show values suggestions

    User->>Popup: Navigate and select value
    Popup->>AutocompleteManager: Return selected value
    AutocompleteManager->>TaskEditor: Insert selected value wrapped in span
</code></pre>
<p>##Workflow
###Triggering the Popup:</p>
<p>When the user types &quot;@&quot; or clicks one of the designated buttons (#addTags, #addActions, #addOracles), the autocomplete popup appears inside the TaskEditor contenteditable area.
The popup initially shows the main categories (tags, actions, oracles).
Selecting a Category:</p>
<p>If the user types a character after &quot;@&quot;, the relevant category is automatically selected.
For example, typing &quot;@t&quot; will show the &quot;tags&quot; category first.
If a button is clicked, the popup directly shows the respective category.
Navigating Suggestions:</p>
<p>As the user continues typing, the popup updates to show the most relevant suggestions.
For instance, typing &quot;@e&quot; after selecting the &quot;tags&quot; category will prioritize the &quot;estimate&quot; property.
Selecting a Property:</p>
<p>The user can navigate the suggestions using the arrow keys.
Pressing &quot;Enter&quot; selects the highlighted suggestion.
Once a property (e.g., estimate) is selected, the popup displays the values related to that property.
Inserting a Value:</p>
<p>The user navigates through the values and selects one.
The selected value is wrapped in a span element with a unique ID and a close button.
For example, typing &quot;@due(&quot; will automatically display the possible values ['5h', '30min', '2h', '1h', '6h', '?due'].
Selecting a value inserts it as <span class="mb-prob mb-tag" id="uniqueID">@due5h<span class="close-prop">x</span></span>.
Removing a Tag:</p>
<p>The user can remove a tag by clicking the close button (x) on the span element.
Example Usage
Typing &quot;@&quot;:
User types &quot;@&quot; in the TaskEditor.
The popup shows categories: tags, actions, oracles.
User types &quot;e&quot;.
The popup shows properties starting with &quot;e&quot;, e.g., estimate under tags.
User selects estimate.
The popup shows values for estimate: ['5h', '30min', '2h', '1h', '6h', '?estimate'].
User selects 5h.
The value 5h is inserted into the TaskEditor as <span class="mb-prob mb-tag" id="uniqueID">@estimate5h<span class="close-prop">x</span></span>.</p>
<h1>Taskape Task Editor</h1>
<p>A vanilla drag-and-drop UI tree for managing tasks, based on David Figatner's drag-and-drop ui tree</p>
<h2>Rationale</h2>
<p>Taskape Task Editor is designed to provide an easy-to-use, drag-and-drop interface for managing hierarchical tasks without the need for frameworks like Vue or React.</p>
<h2>Interaction Diagram</h2>
<pre class="prettyprint source lang-mermaid"><code>sequenceDiagram
    participant User
    participant Tree
    participant Input
    participant Clicked
    participant Leaf
    participant TaskEditor

    User->>Leaf: mousedown/touchstart (double-click)
    Leaf->>Clicked: touchstart(e)
    Leaf->>Clicked: touchend(e)
    Clicked->>Clicked: mousedblclick(e)
    Clicked->>TaskEditor: editTask(Leaf)
    TaskEditor->>TaskEditor: taskArea.innerText = leaf.data.name
    TaskEditor->>TaskEditor: Show editTaskBtn, Hide createTaskBtn

    User->>TaskEditor: Edit text in taskArea
    TaskEditor->>TaskEditor: onTaskAreaInput()
    TaskEditor->>TaskEditor: Update button visibility

    User->>TaskEditor: Click editTaskBtn
    TaskEditor->>Leaf: leaf.data.name = taskArea.innerText.trim()
    TaskEditor->>Tree: tree.update()
    Tree->>Tree: _createLeaf(data, level) (for each leaf)
    Tree->>Tree: Update DOM structure
    TaskEditor->>TaskEditor: resetTaskArea()
</code></pre>
<h2>UML Class Diagram</h2>
<pre class="prettyprint source lang-mermaid"><code>classDiagram
  class Tree {
    -_options: Object
    -_input: Input
    -taskEditor: TaskEditor
    +element: HTMLElement
    +_selection: HTMLElement
    +constructor(tree: Object, options: Object)
    -_createLeaf(data: Object, level: number): Leaf
    -_getChildren(leaf: HTMLElement, all: boolean): HTMLElement[]
    +expandAll()
    -_expandChildren(leaf: HTMLElement)
    +collapseAll()
    -_collapseChildren(leaf: HTMLElement)
    +toggleExpand(leaf: HTMLElement)
    +expand(leaf: HTMLElement) 
    +collapse(leaf: HTMLElement) 
    +update()
    +editData(data: Object)
    +getLeaf(leaf: HTMLElement, root: HTMLElement)
    +findInTree(leaf: HTMLElement, callback: Function)
    -_getFirstChild(element: HTMLElement, all: boolean): HTMLElement
    -_getLastChild(element: HTMLElement, all: boolean): HTMLElement
    -_getParent(element: HTMLElement): HTMLElement
  }

  class Leaf {
    -tree: Tree
    -data: Object
    -level: number
    -element: HTMLElement
    +constructor(tree: Tree, data: Object, level: number)
    +getChildren(all: boolean): HTMLElement[]
    +hideIcon()
    +showIcon()
    +expand()
    +collapse()
    +selectLeaf()
  }

  class Input {
    +_tree: Tree
    +_indicator: Indicator
    +_target: HTMLElement
    +_isDown: Object
    +_offset: Object
    +_holdTimeout: number
    +_moving: boolean
    +_old: Object
    +_closest: Object
    +constructor(tree: Tree)
    -_down(e: Event)
    -_hold()
    -_checkThreshold(e: Event): boolean
    -_pickup()
    -_findClosest(e: Event, entry: HTMLElement)
    -_move(e: Event)
    -_up(e)
    -_moveData()
    -_indicatorMarginLeft(value: number)
  }

  class Indicator {
    +_indicator: HTMLElement
    +constructor(tree: Tree)
    +get(): HTMLElement
    +set marginLeft(value: number)
  }

  class Clicked {
    +Clicked(element, callback, options)
    +destroy()
    +touchstart(e)
    +touchmove(e)
    +touchcancel()
    +touchend(e)
    +mouseclick(e)
    +mousedblclick(e)
  }

  class TaskEditor {
    +tree: Tree
    +currentTask: Leaf | null
    +taskArea: HTMLElement
    +createTaskBtn: HTMLElement
    +editTaskBtn: HTMLElement
    +placeholderText: string
    +constructor(tree: Tree)
    +setupPlaceholder()
    +createTask()
    +updateTask()
    +onTaskAreaInput()
    +resetTaskArea()
    +editTask(leaf: Leaf)
  }

  class Utils {
    +static el(element)
    +static distance(x1, y1, x2, y2)
    +static distancePointElement(px, py, element)
    +static boolean inside(x, y, element)
    +static PointLike toGlobal(e)
    +static object options(options, defaults)
    +static void style(element, style, value)
    +static number percentage(xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2)
    +static void removeChildren(element)
    +static HTMLElement html(options)
    +static number getChildIndex(parent, child)
    +static void attachStyles(styles)
  }

  Tree --> Leaf
  Tree --> TaskEditor
  Input --> Tree
  Input --> Indicator
  Clicked --> Input
  Tree --> Utils

</code></pre>
<h2>Super Simple Example</h2>
<pre class="prettyprint source lang-js"><code>const tasks = {
    task: [
        { 
            name: 'Do the laundry',
            task: [
                { name: 'Get the detergent', task: [] },
                { name: 'Sort the clothes', task: [] },
                { name: 'Put the clothes in the washing machine', task: [] },
                { name: 'Turn on the washing machine', task: [] }
            ] 
        },
        { 
            name: 'Do the dishes',
            task: [
                { name: 'Scrape the dishes', task: [] },
                { name: 'Rinse the dishes', task: [] },
                { name: 'Put the dishes in the dishwasher', task: [] },
                { name: 'Turn on the dishwasher', task: [] }
            ]
        }
    ]
};

const tree = new Tree(tasks, { parent: document.body, edit: true });
tree.expandAll();
</code></pre>
<h2>Features</h2>
<ul>
<li>Drag-and-drop tasks</li>
<li>Indentation for nested tasks</li>
<li>Expand/collapse tasks</li>
<li>Edit task names</li>
<li>Add new tasks</li>
<li>Delete tasks</li>
</ul>
<h2>Tasks</h2>
<p>Tasks are represented as a JavaScript object, where each task is an object with a <code>name</code> string and a <code>task</code> array of subtasks.</p>
<h2>License</h2>
<p>Taskape Task Editor is released under the <a href="https://opensource.org/licenses/MIT">MIT License</a>.</p>
<pre class="prettyprint source"><code>
## Credits
- [David Figatner] </code></pre></article>
    </section>






    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Sun Jul 21 2024 12:23:29 GMT+0300 (Eastern European Summer Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>




<script type="module">
  import mermaid from 'https://unpkg.com/mermaid@10.8.0/dist/mermaid.esm.min.mjs';

  function renderMermaidLangs() {
    [...document.querySelectorAll('.lang-mermaid')].forEach((markdownGraphEl, i) => {
      const graphDefinition = markdownGraphEl.innerText;

      mermaid.render(`mermaid_graph_${i}`, graphDefinition)
        .then(({ svg }) => {
          const graphContainerEl = document.createElement('div');
          graphContainerEl.innerHTML = svg;
          const graphEl = graphContainerEl.querySelector('svg');

          graphEl.style.display = 'block';
          graphEl.style.margin = '0 auto';
          graphContainerEl.style.margin = '50px 0';

          markdownGraphEl.replaceWith(graphContainerEl);
        })
        .catch((err) => console.error('Error rendering Mermaid diagram:', err));
    });
  }

  document.addEventListener('DOMContentLoaded', () => {
    mermaid.initialize({ startOnLoad: true });
    renderMermaidLangs();
  });
</script>
</body>
</html>